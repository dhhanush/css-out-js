const fs = require('fs');
const nodePath = require('path');
const { types } = require('@babel/core');
const { declare } = require('@babel/helper-plugin-utils');
const { default: hash } = require('@emotion/hash');
const { string: toString } = require('to-style');

const prefix = 'css';
let ensuredOutFileExists = false;

/** ignore, dev mode debugger */
const log = (message = '') => {
  fs.appendFileSync(nodePath.join(__dirname, 'debug.log'), JSON.stringify(message, null, 2) + '\n', 'utf8');
};

const cssMap = new Map();

const appendCSS = ({ outFilePath, className, stringifiedStyles }) => {
  // already inserted
  if (cssMap.get(className) === stringifiedStyles) return;

  cssMap.set(className, stringifiedStyles);

  let contents = `/* 
  This file is generated by css-out-js âœ¨
  Don't edit this file directly :)
*/
  `;
  cssMap.forEach((value, key) => {
    contents += `
.${key} {
  ${value}
}`;
  });

  // flush
  fs.writeFileSync(outFilePath, contents);
};

module.exports = declare((api) => {
  api.assertVersion(7);

  const visitor = {
    Program: {
      enter(path, state) {
        const outFilePath = state.opts.path
          ? nodePath.join(state.cwd, state.opts.path)
          : nodePath.join(__dirname, 'out.css'); // should this be state.cwd and not __dirname?

        state.file.set('outFilePath', outFilePath);
        if (state.opts.addImport) state.file.set('moduleSpecifier', outFilePath);

        // reset outfile
        if (!ensuredOutFileExists) {
          fs.writeFileSync(outFilePath, '');
          ensuredOutFileExists = true;
        }
      }
    },
    CallExpression(path, state) {
      const { callee, arguments: args } = path.node;

      if (callee.name !== 'css') return;

      const [arg] = args;

      // if a className string passed, replace expression with className
      if (arg.type === 'Identifier') path.replaceWith(arg);

      if (arg.type !== 'ObjectExpression') return;

      const styles = {};

      arg.properties.forEach((property) => {
        if (['NumericLiteral', 'StringLiteral'].includes(property.value.type)) {
          styles[property.key.name] = property.value.value;
        } else if (types.isExpression(property.value) || types.isIdentifier(property.value)) {
          const rawCode = state.file.code.slice(property.value.start, property.value.end);

          // we wan't an unique custom variable that is
          const uniq = hash(state.filename + rawCode);
          const cssVarName = '--' + rawCode.replace(/\./g, '-').toLowerCase() + '-' + uniq; // example: props-color-ioan3s

          styles[property.key.name] = `var(${cssVarName})`;

          if (path.container.type === 'JSXExpressionContainer') {
            setCSSVarInStyle(path, cssVarName, property);
          } else {
            injectRuntimeExpressionToSetCSSVar(path, cssVarName, property);
          }
        }
      });

      const stringifiedStyles = toString(styles);

      /**
       * Add component name to the className for better naming
       *
       * TODO: for runtime enabled, pass componentName as the second parameter
       *    in case there is a runtime so that the output matches
       */
      let componentName;

      const functionParent = path.getFunctionParent();
      if (types.isArrowFunctionExpression(functionParent)) componentName = functionParent.parent.id.name;
      else if (types.isFunctionDeclaration(functionParent)) componentName = functionParent.node.id.name;

      const className = (componentName || prefix) + '-' + hash(stringifiedStyles);

      /* Write css into outFile */
      const outFilePath = state.file.get('outFilePath');
      appendCSS({ outFilePath, className, stringifiedStyles });

      /* Replace the function call with the className string */
      path.replaceWith(types.stringLiteral(className));
    },
    ImportDeclaration(path, state) {
      if (state.opts.keepRuntime) return;

      if (path.node.source.value === 'css-out-js') {
        const moduleSpecifier = state.file.get('moduleSpecifier');
        if (moduleSpecifier) {
          path.insertAfter(types.importDeclaration([], types.stringLiteral(moduleSpecifier)));
        }
        path.remove();
      }
    }
  };

  return { name: 'babel-plugin-css-out-js', visitor };
});

const setCSSVarInStyle = (path, cssVar, property) => {
  const jsxOpeningElement = path.findParent((path) => path.isJSXOpeningElement());
  const styleAttr = jsxOpeningElement.node.attributes.find((attr) => attr.name.name === 'style');

  const keyVal = types.objectProperty(types.stringLiteral(cssVar), property.value);

  if (styleAttr) {
    styleAttr.value.expression.properties.push(keyVal);
  } else {
    jsxOpeningElement.node.attributes.push(
      types.jsxAttribute(types.jsxIdentifier('style'), types.jsxExpressionContainer(types.objectExpression([keyVal])))
    );
  }
};

const injectRuntimeExpressionToSetCSSVar = (path, cssVar, property) => {
  // TODO: test if (typeof document !== 'undefined')
  const test = types.binaryExpression(
    '!==',
    types.unaryExpression('typeof', types.identifier('document')),
    types.stringLiteral('undefined')
  );

  // consonent: document.documentElement.style.setProperty('--custom', value);
  const consonent = types.expressionStatement(
    types.callExpression(
      types.memberExpression(
        types.memberExpression(
          types.memberExpression(types.identifier('document'), types.identifier('documentElement')),
          types.identifier('style')
        ),
        types.identifier('setProperty')
      ),
      [types.stringLiteral(cssVar), property.value]
    )
  );

  path.parentPath.parentPath.insertAfter(types.ifStatement(test, consonent));
};
